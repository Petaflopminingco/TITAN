```dockerfile
FROM ubuntu:22.04

# Install necessary tools for patching
RUN apt-get update && apt-get install -y --no-install-recommends \
    patch \
    && rm -rf /var/lib/apt/lists/*

# Create a dummy "vulnerable" file for demonstration purposes.
# In a real scenario, this would be an existing application file or source code.
RUN mkdir -p /app && \
    echo "Line 1: This is safe content." > /app/target_file.txt && \
    echo "Line 2: This line contains a simulated vulnerability." >> /app/target_file.txt && \
    echo "Line 3: Another safe line." >> /app/target_file.txt

# Create the patch file directly within the Dockerfile.
# In a real-world scenario, you would typically `COPY your_actual_patch.patch /tmp/`
# from your build context.
RUN printf '%s\n' \
    '--- a/app/target_file.txt' \
    '+++ b/app/target_file.txt' \
    '@@ -1,3 +1,3 @@' \
    ' Line 1: This is safe content.' \
    '-Line 2: This line contains a simulated vulnerability.' \
    '+Line 2: This line has been patched and is now secure.' \
    ' Line 3: Another safe line.' \
    > /tmp/security_fix.patch

WORKDIR /app

# Apply the patch to the target file.
# -p0 is used here if the patch file paths are relative to the current working directory
# and don't have leading directory components to strip. Adjust -pN as needed
# based on how your patch file was generated (e.g., -p1 is common).
RUN patch -p0 < /tmp/security_fix.patch

# Optional: Remove the patch file after application to keep the image clean.
RUN rm /tmp/security_fix.patch

# Optional: Verify the patch has been applied (uncomment to check during build)
# RUN cat /app/target_file.txt

# Define a default command to run when the container starts
CMD ["bash"]
```